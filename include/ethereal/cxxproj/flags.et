fn read_flag_file( file, v ) {
	f = fopen( file, 'r' );
	if f.is_open() {
		f.read_all( v );
	}
}

fn write_flag_file( file, v ) {
	f = fopen( file, 'a' );
	if f.is_open() {
		for e in v.iter() {
			f.write( e + '\n' );
		}
	}
}

fn check_compiler_flag( flag ) {
	if flag.len() > 1 && flag[ 1 ] == 'D' { return true; }
	cmd = "g++ -fsyntax-only " + flag + " -xc++ /dev/null 2>/dev/null";
	res = os.exec( cmd ) == 0;
	return res;
}

mfn< _cxx_proj_t, _cxx_build_t > add_flags( flags ) {
	avail_flags = [];
	not_avail_flags = [];
	read_flag_file( 'flag_cache', avail_flags );
	for flag in flags.iter() {
		cprint( '{y}checking if compiler supports {c}', flag, ' {0}... ' );
		flush_out();
		if avail_flags.find( flag ) >= 0 {
			self.flags.push( flag );
			cprintln( '{g}yes (cached){0}' );
		} elif check_compiler_flag( flag ) {
			self.flags.push( flag );
			not_avail_flags.push( flag );
			cprintln( '{g}yes{0}' );
		} else {
			cprintln( '{r}no{0}' );
		}
	}
	write_flag_file( 'flag_cache', not_avail_flags );
}
